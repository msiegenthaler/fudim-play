package models.playbinding

import java.sql._

/** Connection that prevents certain modifications such as commit, rollback, close. */
private case class ReadOnlyConnection(connection: Connection) extends Connection {
  def close() = {}
  def commit() = {}
  def rollback() = {}
  def rollback(savepoint: Savepoint) = {}

  def setAutoCommit(autoCommit: Boolean) = {}
  def getAutoCommit() = false

  def setReadOnly(readOnly: Boolean) = {}
  def isReadOnly() = true

  def setSavepoint() = connection.setSavepoint()
  def setSavepoint(name: String) = connection.setSavepoint(name)

  def createStatement() = connection.createStatement()
  def createStatement(resultSetType: Int, resultSetConcurrency: Int) = connection.createStatement(resultSetType, resultSetConcurrency)
  def createStatement(resultSetType: Int, resultSetConcurrency: Int, resultSetHoldability: Int) = connection.createStatement(resultSetType, resultSetConcurrency, resultSetHoldability)
  def prepareStatement(sql: String) = connection.prepareStatement(sql)
  def prepareStatement(sql: String, autoGeneratedKeys: Int) = connection.prepareStatement(sql, autoGeneratedKeys)
  def prepareStatement(sql: String, columnIndexes: scala.Array[Int]) = connection.prepareStatement(sql, columnIndexes)
  def prepareStatement(sql: String, resultSetType: Int, resultSetConcurrency: Int) = connection.prepareStatement(sql, resultSetType, resultSetConcurrency)
  def prepareStatement(sql: String, resultSetType: Int, resultSetConcurrency: Int, resultSetHoldability: Int) = connection.prepareStatement(sql, resultSetType, resultSetConcurrency, resultSetHoldability)
  def prepareStatement(sql: String, columnNames: scala.Array[String]) = connection.prepareStatement(sql, columnNames)
  def prepareCall(sql: String) = connection.prepareCall(sql)
  def prepareCall(sql: String, resultSetType: Int, resultSetConcurrency: Int) = connection.prepareCall(sql, resultSetType, resultSetConcurrency)
  def prepareCall(sql: String, resultSetType: Int, resultSetConcurrency: Int, resultSetHoldability: Int) = connection.prepareCall(sql, resultSetType, resultSetConcurrency, resultSetHoldability)
  def clearWarnings() = connection.clearWarnings()
  def createArrayOf(typeName: String, elements: scala.Array[AnyRef]) = connection.createArrayOf(typeName, elements)
  def createBlob() = connection.createBlob()
  def createClob() = connection.createClob()
  def createNClob() = connection.createNClob()
  def createSQLXML() = connection.createSQLXML()
  def createStruct(typeName: String, attributes: scala.Array[AnyRef]) = connection.createStruct(typeName, attributes)
  def getCatalog() = connection.getCatalog()
  def getClientInfo() = connection.getClientInfo()
  def getClientInfo(name: String) = connection.getClientInfo(name)
  def getHoldability() = connection.getHoldability()
  def getMetaData() = connection.getMetaData()
  def getTransactionIsolation() = connection.getTransactionIsolation()
  def getTypeMap() = connection.getTypeMap()
  def getWarnings() = connection.getWarnings()
  def isClosed() = connection.isClosed()
  def isValid(timeout: Int) = connection.isValid(timeout)
  def nativeSQL(sql: String) = connection.nativeSQL(sql)
  def releaseSavepoint(savepoint: Savepoint) = connection.releaseSavepoint(savepoint)
  def setCatalog(catalog: String) = connection.setCatalog(catalog)
  def setClientInfo(properties: java.util.Properties) = connection.setClientInfo(properties)
  def setClientInfo(name: String, value: String) = connection.setClientInfo(name, value)
  def setHoldability(holdability: Int) = connection.setHoldability(holdability)
  def setTransactionIsolation(level: Int) = connection.setTransactionIsolation(level)
  def setTypeMap(map: java.util.Map[String, Class[_]]) = connection.setTypeMap(map)
  def isWrapperFor(iface: Class[_]) = connection.isWrapperFor(iface)
  def unwrap[T](iface: Class[T]) = connection.unwrap(iface)

  //jdbc 4.1
  def getSchema() = connection.asInstanceOf[{ def getSchema(): String }].getSchema()
  def setSchema(schema: String) = connection.asInstanceOf[{ def setSchema(schema: String): Unit }].setSchema(schema)
  def getNetworkTimeout() = connection.asInstanceOf[{ def getNetworkTimeout(): Int }].getNetworkTimeout()
  def setNetworkTimeout(executor: java.util.concurrent.Executor, milliseconds: Int) = {
    connection.asInstanceOf[{
      def setNetworkTimeout(executor: java.util.concurrent.Executor, milliseconds: Int): Unit
    }].setNetworkTimeout(executor, milliseconds)
  }
  def abort(executor: java.util.concurrent.Executor) = {
    connection.asInstanceOf[{
      def abort(executor: java.util.concurrent.Executor): Unit
    }].abort(executor)
  }
}
